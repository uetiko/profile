<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>√Ångel Barrientos ‚Äî Retro Desktop</title>
  <meta name="description" content="CV interactivo de √Ångel Barrientos en formato de escritorio retro (Win95/GNOME 1)." />
  <link rel="icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 64 64'%3E%3Crect width='64' height='64' rx='12' fill='%23000'/%3E%3Ctext x='50%' y='52%' dominant-baseline='middle' text-anchor='middle' font-size='36' fill='%23fff'%3EA%3C/text%3E%3C/svg%3E" />

  <style>
    :root {
      --bg: #0a0c10;
      --desk: #0f131a; /* retro dark */
      --panel: #0b0f15;
      --panel-border: #1c2430;
      --win: rgba(24, 32, 44, 0.82);
      --win-solid: #18202c;
      --win-border: #5f748f;
      --accent: #7cc5ff;
      --text: #e7edf5;
      --muted: #9fb3c9;
      --shadow: 0 10px 30px rgba(0,0,0,.5);
      --radius: 12px;
      --z-panel: 1000;
      --z-menu: 9999;
      --z-window: 1200;
      --z-tooltip: 1400;
    }
    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body {
      margin: 0;
      background: radial-gradient(1200px 800px at 20% 10%, #111927 0%, #0a0c10 60%, #06080d 100%);
      color: var(--text);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
      user-select: none;
      overflow: hidden;
    }
    /* Desktop */
    .desktop {
      position: fixed; inset: 0; display: grid; grid-template-rows: 1fr 42px;
      background-image:
        url("https://fedoraproject.org/w/uploads/f/f9/F42-01-night.jpg"),
        radial-gradient(1px 1px at 25% 30%, rgba(124,197,255,.15) 0, transparent 60%),
        radial-gradient(1px 1px at 70% 60%, rgba(124,197,255,.08) 0, transparent 60%);
      background-size: cover, auto, auto;
      background-position: center;
      background-repeat: no-repeat;
    }
    .desktop-grid { padding: 20px; display: grid; grid-auto-rows: 92px; grid-template-columns: repeat(auto-fill, 92px); gap: 18px; align-content: start; }
    .icon { width: 92px; height: 92px; display: grid; grid-template-rows: 56px 1fr; place-items: center; border-radius: 10px; cursor: default; }
    .icon:hover { background: rgba(255,255,255,0.04); }
    .icon img { width: 42px; height: 42px; filter: drop-shadow(0 1px 3px rgba(0,0,0,.6)); }
    .icon span { text-align: center; font-size: 12px; color: var(--muted); padding: 0 6px; }
    /* Panel */
    .panel { position: relative; grid-row: 2; display: grid; grid-template-columns: 220px 1fr 280px; align-items: center; gap: 12px; padding: 6px 10px; background: var(--panel); border-top: 1px solid var(--panel-border); box-shadow: 0 -12px 24px rgba(0,0,0,.35) inset; z-index: var(--z-panel); }
    .start { display: flex; align-items: center; gap: 8px; background: #0c121a; padding: 6px 10px; border: 1px solid #1b2633; border-radius: 8px; cursor: default; }
    .start:hover { outline: 1px solid #2b3a4e; }
    .start svg { width: 16px; height: 16px; }
    .taskbar { display: flex; gap: 8px; overflow-x: auto; padding: 2px; scrollbar-width: thin; }
    .task { background: #0d141d; border: 1px solid #1c2736; border-radius: 8px; padding: 6px 10px; font-size: 12px; color: var(--muted); white-space: nowrap; cursor: default; }
    .task.active { outline: 1px solid var(--accent); color: var(--text); }
    .status { display: flex; gap: 10px; justify-content: end; align-items: center; font-size: 12px; color: var(--muted); }
    .badge { padding: 4px 8px; border: 1px solid #1c2736; border-radius: 8px; }
    /* Start Menu */
    .menu {
      position: fixed;
      bottom: 50px;
      left: 10px;
      width: 320px;
      background: #0d131b;
      border: 1px solid #1b2736; border-radius: 14px; box-shadow: var(--shadow); padding: 10px; display: grid; gap: 8px;
      z-index: var(--z-menu);
    }
    .menu .item { padding: 10px; border-radius: 10px; display: grid; grid-template-columns: 24px 1fr auto; gap: 10px; align-items: center; cursor: default; }
    .menu .item:hover { background: rgba(255,255,255,0.05); }
    .menu .hint { font-size: 11px; color: var(--muted); }
    /* Windows */
    .window { position: absolute; top: 140px; left: 140px; width: 720px; min-width: 340px; height: 460px; min-height: 220px; background: var(--win); border: 1px solid var(--win-border); border-radius: var(--radius); box-shadow: var(--shadow); display: grid; grid-template-rows: 38px 1fr; overflow: hidden; backdrop-filter: blur(12px) saturate(1.05); -webkit-backdrop-filter: blur(12px) saturate(1.05); }
    .window.solid { background: var(--win-solid); backdrop-filter: none; -webkit-backdrop-filter: none; }
    .titlebar { display: grid; grid-template-columns: 1fr auto; align-items: center; gap: 8px; padding: 0 8px; background: linear-gradient(180deg, rgba(124,197,255,.12), rgba(124,197,255,0)); border-bottom: 1px solid rgba(124,197,255,.18); cursor: move; }
    .titlebar .title { display: flex; align-items: center; gap: 8px; font-size: 13px; color: var(--text); }
    .titlebar .controls { display: flex; gap: 6px; }
    .btn { width: 28px; height: 24px; display: grid; place-items: center; border: 1px solid #2a3a50; border-radius: 8px; background: #0d141d; cursor: default; }
    .btn:hover { outline: 1px solid var(--accent); }
    .content { padding: 16px; overflow: auto; }
    .resizer { position: absolute; right: 0; bottom: 0; width: 14px; height: 14px; cursor: nwse-resize; }
    .ghost { position:absolute; border:2px dashed rgba(124,197,255,.6); border-radius: var(--radius); pointer-events:none; }
    a, .link { color: var(--accent); text-decoration: none; }
    .kbd { font: 12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; background: #0b1118; border: 1px solid #1c2736; border-radius: 6px; padding: 2px 6px; }
    .grid { display: grid; gap: 10px; }
    .cols-2 { grid-template-columns: repeat(2, minmax(0, 1fr)); }
    .muted { color: var(--muted); }
    .hr { height: 1px; background: #1c2736; margin: 8px 0; }
    .pill { font-size: 12px; padding: 4px 8px; border-radius: 999px; background: rgba(124,197,255,.1); border: 1px solid rgba(124,197,255,.25); }
    .list { display: grid; gap: 8px; }
    .list li { margin-left: 18px; }
    @media (max-width: 840px) {
      .window { width: calc(100vw - 24px); left: 12px; }
      .desktop-grid { grid-template-columns: repeat(auto-fill, 76px); grid-auto-rows: 88px; gap: 12px; }
      .icon { width: 76px; height: 88px; }
    }
    /* --- compositor: transiciones base y material --- */
    .window {
      transition: transform .24s ease, opacity .24s ease, box-shadow .18s ease;
      will-change: transform, opacity, box-shadow;
    }
    .window.is-opening { opacity: 0; transform: scale(.96); }
    .window.is-open    { opacity: 1; transform: scale(1); }
    .window.is-closing { opacity: 0; transform: scale(.96); }

    .window.has-shadow-weak  { box-shadow: 0 6px 18px rgba(0,0,0,.35); }
    .window.has-shadow-strong{ box-shadow: 0 16px 40px rgba(0,0,0,.55); }

    /* Efectos avanzados */
    .window.fly {
      transition: transform .24s ease, opacity .24s ease !important;
    }

    @keyframes shake-x {
      10%, 90% { transform: translateX(-2px); }
      20%, 80% { transform: translateX(4px); }
      30%, 50%, 70% { transform: translateX(-6px); }
      40%, 60% { transform: translateX(6px); }
    }
    .window.shake { animation: shake-x .28s ease; }

    @keyframes pulse-attn {
      0%, 100% { box-shadow: 0 0 0 rgba(124,197,255,0); }
      50% { box-shadow: 0 0 0 3px rgba(124,197,255,.35); }
    }
    .task.attention { animation: pulse-attn 1.2s ease-in-out 2; }
    .window.attention { animation: pulse-attn 1.2s ease-in-out 2; }

    .window {
      transition: transform .24s ease, opacity .24s ease, box-shadow .18s ease, backdrop-filter .24s ease, background .24s ease;
      will-change: transform, opacity, box-shadow;
    }

    .desktop.parallax {
      transition: background-position .06s linear;
    }
  </style>
  <!-- GA4: sustituye G-XXXXXX por tu Measurement ID -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-XXXXXX"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){ dataLayer.push(arguments); }
    gtag('js', new Date());
    gtag('config', 'G-XXXXXX', { transport_type: 'beacon', send_page_view: false });
  </script>
</head>
<body>
<div id="app" class="desktop" @contextmenu.prevent>
  <!-- Desktop icons -->
  <div class="desktop-grid">
    <div class="icon" tabindex="0" @dblclick="openApp('about')" @click="telemetry.click('icon', {element:'about'})">
      <img alt="About" src="https://api.iconify.design/mdi:account-badge.svg" />
      <span>{{ t('icons.about') }}</span>
    </div>
    <div class="icon" tabindex="0" @dblclick="openApp('experience')" @click="telemetry.click('icon', {element:'experience'})">
      <img alt="Experience" src="https://api.iconify.design/mdi:briefcase.svg" />
      <span>{{ t('icons.experience') }}</span>
    </div>
    <div class="icon" tabindex="0" @dblclick="openApp('skills')" @click="telemetry.click('icon', {element:'skills'})">
      <img alt="Skills" src="https://api.iconify.design/mdi:code-tags.svg" />
      <span>{{ t('icons.skills') }}</span>
    </div>
    <div class="icon" tabindex="0" @dblclick="openApp('education')" @click="telemetry.click('icon', {element:'education'})">
      <img alt="Education" src="https://api.iconify.design/mdi:school.svg" />
      <span>{{ t('icons.education') }}</span>
    </div>
    <div class="icon" tabindex="0" @dblclick="openApp('download')" @click="telemetry.click('icon', {element:'download'})">
      <img alt="Download CV" src="https://api.iconify.design/mdi:file-download.svg" />
      <span>{{ t('icons.cv') }}</span>
    </div>
    <div class="icon" tabindex="0" @dblclick="openApp('contact')" @click="telemetry.click('icon', {element:'contact'})">
      <img alt="Contact" src="https://api.iconify.design/mdi:email.svg" />
      <span>{{ t('icons.contact') }}</span>
    </div>
  </div>

  <!-- Windows -->
  <template v-for="win in windows">
    <div class="window" :class="{solid: !compositor.glass}" :style="win.style" :key="win.id" :data-win-id="win.id" @mousedown="focus(win.id)">
      <div class="titlebar" @dblclick="toggleMaximize(win.id)" @mousedown="startDrag($event, win.id)">
        <div class="title">
          <span class="pill">{{ win.icon }}</span>
          <span>{{ win.title }}</span>
        </div>
        <div class="controls">
          <div class="btn" title="Minimize" @click.stop="minimize(win.id); telemetry.cta('window_minimize',{
          name:win.id,
          element:'minimize_button',
          variant:win.minimized ? 'minimize' : 'restore'
          })">‚Äì</div>
          <div class="btn" title="Maximize" @click.stop="toggleMaximize(win.id); telemetry.cta('window_maximize',{
          name:win.id,
          element:'maximize_button',
          variant:win.maximized ? 'maximize' : 'restore'
          })">‚ñ¢</div>
          <div class="btn" title="Close" @click.stop="closeWindow(win.id); telemetry.cta('window_close',{
          name:win.id,
          element:'close_button'
          })">√ó</div>
        </div>
      </div>
      <div class="content">
        <component
          :is="win.component"
          :t="t"
          :lang="lang"
          v-bind="win.props"
          @open-viewer="openViewer"
          @download="telemetry.download({name: win.id, element:'link'})"
          @submit="telemetry.formSubmit($event)"
        />
      </div>
      <div class="resizer" @mousedown="startResize($event, win.id)"></div>
    </div>
  </template>
  <div v-if="drag.ghost" class="ghost" :style="drag.ghostStyle"></div>

  <!-- Panel / Taskbar -->
  <div class="panel">
    <div class="start" @click="ui.menu = !ui.menu; telemetry.click('start_button',{element:'start'})">
      <svg viewBox="0 0 24 24" fill="currentColor"><path d="M4 4h7v7H4V4m9 0h7v7h-7V4M4 13h7v7H4v-7m9 0h7v7h-7v-7Z"/></svg>
      <strong>Start</strong>
    </div>
    <div class="taskbar">
      <div v-for="task in tasks" :key="task.id" :data-id="task.id" class="task" :class="{active: task.active}" @click="restore(task.id); focus(task.id)">{{ task.title }}</div>
    </div>
    <div class="status">
      <span class="badge">{{ clock }}</span>
      <span class="badge" title="Language">
          <span class="link" @click="setLang(lang === 'es' ? 'en' : 'es')">{{ lang.toUpperCase() }}</span>
        </span>
      <span class="muted">{{ env }} ¬∑ {{ appName }}</span>
    </div>
  </div>
  <!-- Start Menu -->
  <div v-if="ui.menu" class="menu" @click.outside>
    <div class="item" @click="openApp('about'); ui.menu=false">
      <span>üõà</span><div>{{ t('menu.about') }}<div class="hint">{{ t('menu.about_hint') }}</div></div><span class="kbd">Enter</span>
    </div>
    <div class="item" @click="openApp('experience'); ui.menu=false"><span>üíº</span><div>{{ t('menu.experience') }}</div><span></span></div>
    <div class="item" @click="openApp('skills'); ui.menu=false"><span>üß∞</span><div>{{ t('menu.skills') }}</div><span></span></div>
    <div class="item" @click="openApp('education'); ui.menu=false"><span>üéì</span><div>{{ t('menu.education') }}</div><span></span></div>
    <div class="item" @click="openApp('download'); ui.menu=false"><span>‚¨á</span><div>{{ t('menu.download') }}</div><span></span></div>
    <div class="item" @click="openApp('contact'); ui.menu=false"><span>‚úâ</span><div>{{ t('menu.contact') }}</div><span></span></div>
    <div class="hr"></div>
    <div class="item" @click="compositor.toggleGlass(); telemetry.cta('toggle_compositor',{variant: compositor.glass ? 'glass' : 'solid'})"><span>ü™ü</span><div>{{ t('menu.compositor') }}</div><span></span></div>
  </div>
</div>

<!-- Vue 3 (CDN) -->
<script src="https://unpkg.com/vue@3/dist/vue.global.prod.js"></script>
<script type="module">
  /* ============================
     Utilities & Kernel Services
     ============================ */
  /**
   * Generates a random UUID (Universally Unique Identifier) following the RFC4122 version 4 standard.
   * This implementation does not use cryptographic functionality, ensuring maximum compatibility across environments.
   *
   * The generated UUID has the format `xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx` where:
   * - `x` is replaced with a random hexadecimal digit (0-9, a-f).
   * - The `y` position is replaced with a random hexadecimal digit in the range 8-11.
   *
   * @returns {string} A randomly generated RFC4122 v4 UUID.
   */
  const uuidv4 = () => {
    // RFC4122 v4, no crypto for max compatibility
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c => {
      const r = Math.random() * 16 | 0, v = c === 'x' ? r : (r & 0x3 | 0x8); return v.toString(16);
    });
  };

  const nowISO = () => new Date().toISOString();

  /* i18n minimal */
  /**
   * Multilingual content and labels for the UI.
   *
   * This object contains structured translations for different segments of the application in Spanish (es) and English (en).
   */
  const messages = {
    es: {
      icons: { about: 'Acerca de m√≠', experience: 'Experiencia', skills: 'Skills', education: 'Educaci√≥n', cv: 'Descargar CV', contact: 'Contacto' },
      menu: { about: 'Acerca de √Ångel', about_hint: 'Perfil y resumen ejecutivo', experience: 'Experiencia', skills: 'Competencias t√©cnicas', education: 'Formaci√≥n', download: 'Descargar CV (PDF)', contact: 'Contacto', compositor: 'Alternar compositor (vidrio/s√≥lido)' },
      about: {
        title: '√Ångel Barrientos ‚Äî Technical Lead & Software Architect',
        summary: 'Ingeniero en sistemas con 15+ a√±os en backend, arquitectura y liderazgo t√©cnico. Enfocado en e‚Äëcommerce, AWS y modernizaci√≥n de infraestructura.'
      },
      experience: {
        title: 'Experiencia profesional destacada'
      },
      skills: { title: 'Competencias t√©cnicas' },
      education: { title: 'Formaci√≥n y aprendizaje continuo' },
      download: { title: 'Descarga de CV', hint: 'Versi√≥n ejecutiva en PDF para reclutadores.' },
      contact: { title: 'Contacto directo' }
    },
    en: {
      icons: { about: 'About me', experience: 'Experience', skills: 'Skills', education: 'Education', cv: 'Download CV', contact: 'Contact' },
      menu: { about: 'About √Ångel', about_hint: 'Profile & executive summary', experience: 'Experience', skills: 'Technical skills', education: 'Education', download: 'Download CV (PDF)', contact: 'Contact', compositor: 'Toggle compositor (glass/solid)' },
      about: {
        title: '√Ångel Barrientos ‚Äî Technical Lead & Software Architect',
        summary: 'Software engineer with 15+ years in backend, architecture, and technical leadership. Focused on e‚Äëcommerce, AWS, and modernization.'
      },
      experience: { title: 'Highlighted professional experience' },
      skills: { title: 'Technical competencies' },
      education: { title: 'Education & continuous learning' },
      download: { title: 'CV download', hint: 'Executive PDF version for recruiters.' },
      contact: { title: 'Direct contact' }
    }
  };

  const i18n = (lang) => (key) => key.split('.').reduce((o,k)=> (o||{})[k], messages[lang]) || key;

  /**
   * A class for managing client-side telemetry, allowing for the tracking and sending of user interaction events
   * such as page views, clicks, and custom event types. This class utilizes the `gtag` library if available,
   * falling back to debug logs when the library is not present.
   */
  class Telemetry {
    constructor({ env = 'dev', app = 'desktop' } = {}) {
      this.env = env; this.app = app;
      this.session_id = sessionStorage.getItem('session_id') || uuidv4();
      sessionStorage.setItem('session_id', this.session_id);
      this.client_id = undefined; // optional ‚Äî try GA4 fetch
      try {
        if (window.gtag) {
          // Attempt to get GA4 client_id (best-effort; async via callback signature)
          // Replace 'G-XXXXXX' below if you want this to work in production
          window.gtag('get', 'G-XXXXXX', 'client_id', (cid) => { this.client_id = cid; });
        }
      } catch {}
    }
    /**
     * Constructs a base event object with various default properties.
     *
     * @return {Object} An object containing the following properties:
     * - event_id: A unique identifier for the event.
     * - ts: The current timestamp in ISO format.
     * - page_path: The path of the current page.
     * - page_location: The full URL of the current page.
     * - page_title: The title of the current page.
     * - env: The environment from which the event is being sent.
     * - app: The application identifier related to the event.
     * - session_id: The current session's unique identifier.
     * - client_id: The unique identifier for the client.
     * - transport_type: The transport method used for sending this event (default is 'beacon').
     */
    base() {
      return {
        event_id: uuidv4(),
        ts: nowISO(),
        page_path: location.pathname,
        page_location: location.href,
        page_title: document.title,
        env: this.env,
        app: this.app,
        session_id: this.session_id,
        client_id: this.client_id,
        transport_type: 'beacon'
      };
    }
    /**
     * Sends an event with the specified name and additional data.
     *
     * @param {string} name - The name of the event to be sent.
     * @param {Object} [extra={}] - Optional additional data to include with the event.
     * @return {void}
     */
    send(name, extra = {}) {
      const payload = { ...this.base(), ...extra };
      if (window.gtag) {
        window.gtag('event', name, payload);
      } else {
        console.debug('[telemetry:fallback]', name, payload);
      }
    }
    pageView(extra={}){ this.send('page_view', extra); }
    click(scope, extra={}){ this.send('click', { scope, ...extra }); }
    cta(name, extra={}){ this.send('cta', { name, ...extra }); }
    openWindow(name, extra={}){ this.send('open_window', { name, ...extra }); }
    closeWindow(name, extra={}){this.send('close_window', { name, ...extra }); }
    formSubmit(extra){ this.send('form_submit', {...extra}); }
    download(extra){ this.send('download', {...extra}); }
    videoPlay(extra){ this.send('video_play', {...extra}); }
    error(scope, extra){ this.send('error', { scope, ...extra }); }
  }

  /**
   * Manages a stack of window instances with functionality to create, focus, minimize,
   * maximize, restore, close, and style windows.
   */
  class WindowManager {
    constructor() { this.stack = []; this.z = 2000; }
    create({ id, title, icon, component, x=120, y=120, w=720, h=460 }) {
      const win = { id, title, icon, component, x, y, w, h, minimized: false, maximized: false, z: ++this.z };
      this.stack.push(win); return win;
    }
    /**
     * Adjusts the z-index of the specified window and updates the window stack order.
     *
     * @param {string} id - The unique identifier of the window to focus.
     * @return {void} - Does not return a value.
     */
    focus(id){ const w = this.find(id); if (!w) return; w.z = ++this.z; this.stack = this.stack.sort((a,b)=>a.z-b.z); }
    /**
     * Searches for an item in the stack by its unique identifier and returns it if found.
     *
     * @param {number|string} id - The unique identifier of the item to be searched.
     * @return {Object|undefined} The item matching the given id, or undefined if not found.
     */
    find(id){ return this.stack.find(w=>w.id===id); }
    /**
     * Closes and removes an item from the stack based on the provided identifier.
     *
     * @param {string|number} id - The unique identifier of the item to close and remove.
     * @return {void} Does not return any value.
     */
    close(id){ this.stack = this.stack.filter(w=>w.id!==id); }
    /**
     * Minimizes the object identified by the given ID.
     *
     * @param {string|number} id - The unique identifier of the object to minimize.
     * @return {void} Does not return a value.
     */
    minimize(id){ const w=this.find(id); if(w){ w.minimized=true; } }
    /**
     * Restores a specific window by its identifier, setting its minimized state to false
     * and bringing it into focus.
     *
     * @param {string|number} id The identifier of the window to be restored.
     * @return {void}
     */
    restore(id){ const w=this.find(id); if(w){ w.minimized=false; this.focus(id);} }
    /**
     * Toggles the maximized state of a specific window identified by its ID.
     * If the window is maximized, it restores the previous dimensions and position.
     * If the window is not maximized, it adjusts its size and position to fit the screen.
     *
     * @param {string} id - The unique identifier of the window to be toggled.
     * @return {void} This method does not return a value.
     */
    toggleMax(id){ const w=this.find(id); if(!w) return; w.maximized=!w.maximized; if(w.maximized){ w.prev={x:w.x,y:w.y,w:w.w,h:w.h}; w.x=12; w.y=12; w.w=innerWidth-24; w.h=innerHeight-54; } else if(w.prev){ Object.assign(w, w.prev); w.prev=undefined; }
    }
    /**
     * Generates a style string for a given window object based on its properties.
     *
     * @param {Object} win - The window object containing style attributes.
     * @param {number} win.z - The z-index of the window.
     * @param {boolean} win.minimized - Indicates whether the window is minimized.
     * @param {number} win.x - The x-coordinate (left position) of the window.
     * @param {number} win.y - The y-coordinate (top position) of the window.
     * @param {number} win.w - The width of the window.
     * @param {number} win.h - The height of the window.
     * @return {string} A string representing the CSS style for the window.
     */
    style(win){
      const base = `z-index:${win.z};` + (win.minimized? 'display:none;' : '');
      return base + `left:${win.x}px;top:${win.y}px;width:${win.w}px;height:${win.h}px;`;
    }
    /**
     * Synchronizes the current state of a specific window to its corresponding DOM element.
     *
     * @param {string} id - The identifier of the window to synchronize.
     * @return {void} Does not return any value.
     */
    syncToDOM(id) {
      const w = this.find(id);
      if (!w) return;
      const el = document.querySelector(`.window[data-win-id="${id}"]`);
      if (!el) return;
      el.style.cssText = this.style(w);
    }
  }

  /* ============================
     EventBus, State & Effect Managers
     ============================ */
  /**
   * EventBus is a simple implementation of the observer pattern that facilitates event subscription, unsubscription, and event emission.
   */
  class EventBus {
    constructor(){ this.map = new Map(); }
    on(evt, handler){ if(!this.map.has(evt)) this.map.set(evt, new Set()); this.map.get(evt).add(handler); return ()=>this.off(evt, handler); }
    off(evt, handler){ const s=this.map.get(evt); if(s){ s.delete(handler); if(!s.size) this.map.delete(evt); } }
    emit(evt, payload){ const s=this.map.get(evt); if(s){ for(const h of [...s]){ try{ h(payload); }catch(e){ console.debug('[bus:error]', evt, e); } } } }
  }

  /**
   * Manages application state through a centralized object with helper methods.
   * Provides functionality to get, set, toggle, and retrieve a snapshot of the current state.
   */
  class StateManager {
    /**
     * Creates an instance of the class with configurable initialization.
     *
     * @param {Object} [init={}] An object that specifies initial states for the instance.
     * @param {boolean} [init.glass=true] Whether the glass effect is enabled.
     * @param {string} [init.wallpaper='https://fedoraproject.org/w/uploads/f/f9/F42-01-night.jpg'] The URL of the wallpaper image.
     * @param {string} [init.fit='cover'] Determines how the wallpaper image is resized to fit its container.
     * @param {boolean} [init.effectsEnabled=true] Indicates whether visual effects are enabled.
     * @param {boolean} [init.reducedMotion=false] Indicates whether motion should be reduced for accessibility purposes.
     * @param {number} [init.animationSpeed=1.0] Multiplier factor for animation speed where 1.0 is normal speed.
     *
     * @return {void}
     */
    constructor(init = {}){
      this.state = Object.assign({
        glass: true,
        wallpaper: 'https://fedoraproject.org/w/uploads/f/f9/F42-01-night.jpg',
        fit: 'cover',
        effectsEnabled: true,
        reducedMotion: false,
        animationSpeed: 1.0 // factor multiplicador (1 = normal)
      }, init);
    }
    /**
     * Retrieves the value associated with the specified key from the state.
     *
     * @param {string} key - The key whose associated value is to be returned.
     * @return {*} The value associated with the given key, or undefined if the key does not exist.
     */
    get(key){ return this.state[key]; }
    /**
     * Sets a value in the state object with the specified key and returns a snapshot of the updated state.
     *
     * @param {string} key - The key to associate with the value in the state object.
     * @param {*} val - The value to be set for the specified key in the state object.
     * @return {Object} A snapshot of the updated state after the key-value pair has been set.
     */
    set(key, val){ this.state[key] = val; return this.snapshot(); }
    /**
     * Toggles the boolean value associated with the given key in the state object.
     * If the current value is true, it will be set to false, and vice versa.
     *
     * @param {string} key - The key in the state object whose value is to be toggled.
     * @return {Object} The current snapshot of the updated state object.
     */
    toggle(key){ this.state[key] = !this.state[key]; return this.snapshot(); }
    /**
     * Creates a snapshot of the current state.
     *
     * @return {Object} A shallow clone of the current state.
     */
    snapshot(){ return {...this.state}; }
  }

  /**
   * Manages the lifecycle and execution of various registered effects.
   *
   * The EffectManager class provides functionality to register, unregister, and play
   * effects. It communicates with a provided event bus, manages state dependencies,
   * and logs telemetry data related to effect execution.
   */
  class EffectManager {
    /**
     * Creates an instance of the class with the specified dependencies and initializes internal properties.
     *
     * @param {Object} options An object containing the required dependencies.
     * @param {Object} options.bus The bus object used for communication or event handling.
     * @param {Object} options.state The state management object used for storing or managing state data.
     * @param {Object} options.telemetry The telemetry object used for logging or monitoring data.
     * @return {void} Does not return a value.
     */
    constructor({ bus, state, telemetry }){
      this.bus = bus; this.state = state; this.telemetry = telemetry;
      this.registry = new Map();
    }
    /**
     * Registers a handler associated with a specific type.
     *
     * @param {string} type - The type for which the handler is being registered.
     * @param {Function} handler - The function to handle the specified type.
     * @return {void}
     */
    register(type, handler){ this.registry.set(type, handler); }
    /**
     * Unregisters a specified type from the registry.
     *
     * @param {string} type - The key representing the type to be removed from the registry.
     * @return {boolean} Returns true if the type was successfully deleted, false otherwise.
     */
    unregister(type){ this.registry.delete(type); }
    /**
     * Executes an effect registered within the system, adjusting its behavior based on state configurations.
     *
     * @param {string} type - The type of effect to be played, which must be registered in the registry.
     * @param {Object} ctx - The context object containing necessary data for the effect execution.
     * @param {string} [ctx.id] - The identifier for the target associated with the effect.
     * @return {Promise<void>} Resolves when the effect is successfully executed.
     */
    async play(type, ctx){
      if(!this.registry.has(type)) return;
      const start = performance.now();
      this.bus?.emit('effect.start', { type, target: ctx?.id });
      const factor = (this.state.get('reducedMotion') ? 0.01 : (this.state.get('animationSpeed')||1));
      await this.registry.get(type)({
        ...ctx,
        state: this.state.snapshot(),
        speed: factor
      });
      const dur = performance.now() - start;
      this.bus?.emit('effect.end', { type, target: ctx?.id, duration: dur });
      this.telemetry?.cta?.('effect', { name:type, duration: Math.round(dur) });
    }
  }

  /* ------- Efectos por defecto (MVP) ------- */
  /**
   * A private asynchronous function that waits for two animation frames before resolving a Promise.
   *
   * This function uses the `requestAnimationFrame` Web API to delay execution until two consecutive
   * animation frame requests have occurred. It is typically used to ensure that DOM updates
   * have been applied and rendered before executing subsequent logic.
   *
   * @returns {Promise<void>} A promise that resolves after two animation frames.
   * @private
   */
  const _nextFrame = () => new Promise(r=>requestAnimationFrame(()=>requestAnimationFrame(r)));
  /**
   * Handles the addition and removal of CSS classes on a specified element
   * and waits for the next animation frame.
   *
   * @param {HTMLElement} el - The target HTML element to modify classes for.
   * @param {string} add - The name of the CSS class to add to the target element.
   * @param {string[]} [remove=[]] - An optional array of CSS class names to remove from the target element.
   * @returns {Promise<void>} Resolves after the next animation frame.
   */
  const _withClass = async (el, add, remove=[]) => {
    if(!el) return;
    remove.forEach(c=>el.classList.remove(c));
    el.classList.add(add);
    await _nextFrame();
  };
  /**
   * Awaits the completion of a CSS transition on an element or resolves after a timeout.
   *
   * This function listens for the `transitionend` event on the provided element to detect
   * when its CSS transition has completed. If the event does not occur within the specified
   * timeout period, the promise resolves automatically.
   *
   * @param {HTMLElement} el - The target HTML element to monitor for the `transitionend` event.
   * @param {number} [timeout=320] - The timeout duration in milliseconds to wait for the transition to complete.
   * @returns {Promise<void>} A promise that resolves when the transition ends or the timeout elapses.
   */
  const _awaitTransition = (el, timeout=320) => new Promise(resolve => {
    if(!el) return resolve();
    let done=false;
    const to = setTimeout(()=>{ if(!done){ done=true; resolve(); } }, timeout+40);
    const onEnd = (e)=>{ if(e.target!==el) return; if(!done){ done=true; clearTimeout(to); el.removeEventListener('transitionend', onEnd); resolve(); } };
    el.addEventListener('transitionend', onEnd, { once:true });
  });

  /**
   * Registers a set of default visual and motion effects to the provided effect manager instance.
   * Each effect is added to handle transitions, animations, material designs, feedback, and ambient interactions.
   * These effects allow for dynamic element state transitions and user interaction responses.
   *
   * @param {Object} effectManager - The effect manager instance where the default effects are registered.
   * @return {void} - This function does not return anything.
   */
  function registerDefaultEffects(effectManager){
    // Transici√≥n: abrir
    effectManager.register('transition:open', async ({ element, speed=1 })=>{
      if(!element) return;
      element.classList.add('is-opening');
      await _nextFrame();
      element.classList.add('is-open');
      element.classList.remove('is-opening');
      await _awaitTransition(element, 240 / speed);
    });

    // Transici√≥n: cerrar
    effectManager.register('transition:close', async ({ element, speed=1 })=>{
      if(!element) return;
      element.classList.add('is-closing');
      element.classList.remove('is-open');
      await _awaitTransition(element, 240 / speed);
      // Cleanup aunque el DOM se vaya a retirar
      element.classList.remove('is-closing');
    });

    // Transici√≥n: minimizar (cierra visualmente y deja el DOM limpio para restore)
    effectManager.register('transition:minimize', async ({ element, speed=1 })=>{
      if(!element) return;
      element.classList.add('is-closing');
      element.classList.remove('is-open');
      await _awaitTransition(element, 220 / speed);
      // üîß CLAVE: limpiar estado para que restore no quede transparente
      element.classList.remove('is-closing');
    });

    // Transici√≥n: restore (de estado visible pero sin 'is-open' ‚Üí a abierto)
    effectManager.register('transition:restore', async ({ element, speed=1 })=>{
      if(!element) return;
      element.classList.remove('is-closing');
      // Punto de partida sin salto
      element.style.willChange = 'opacity, transform';
      element.style.opacity = '0';
      element.style.transform = 'scale(.98)';
      await _nextFrame();
      element.classList.add('is-open');
      element.style.opacity = '';
      element.style.transform = '';
      await _awaitTransition(element, 200 / speed);
      element.style.willChange = '';
    });

    // Material: sombra seg√∫n foco
    effectManager.register('material:shadow:weak', async ({ element })=>{
      if(!element) return;
      element.classList.add('has-shadow-weak');
      element.classList.remove('has-shadow-strong');
    });
    effectManager.register('material:shadow:strong', async ({ element })=>{
      if(!element) return;
      element.classList.add('has-shadow-strong');
      element.classList.remove('has-shadow-weak');
    });

    // Motion: minimize hacia taskbar (FLIP)
    effectManager.register('motion:to-taskbar', async ({ id, element, speed=1, getTaskEl })=>{
      if(!element) return;
      const taskEl = getTaskEl?.(id);
      if(!taskEl) return; // fallback: no animar si no hay task

      const from = element.getBoundingClientRect();
      const to = taskEl.getBoundingClientRect();
      const dx = (to.left + to.width/2) - (from.left + from.width/2);
      const dy = (to.top + to.height/2) - (from.top + from.height/2);
      const s  = Math.max(0.08, Math.min(0.12, (to.width/from.width))); // escala peque√±a

      element.classList.add('fly');
      element.style.transformOrigin = 'center center';
      element.style.transform = `translate(${dx}px, ${dy}px) scale(${s})`;
      element.style.opacity = '0';
      await _awaitTransition(element, 220 / speed);
      // cleanup
      element.classList.remove('fly');
      element.style.transform = '';
      element.style.opacity = '';
    });

    // Feedback: shake para acciones inv√°lidas
    effectManager.register('feedback:shake', async ({ element })=>{
      if(!element) return;
      element.classList.add('shake');
      await _awaitTransition(element, 280);
      element.classList.remove('shake');
    });

    // Attention: pulse en task
    effectManager.register('attention:task', async ({ id, getTaskEl })=>{
      const el = getTaskEl?.(id); if(!el) return;
      el.classList.add('attention');
      await _awaitTransition(el, 1200*2);
      el.classList.remove('attention');
    });

    // Attention: pulse en ventana
    effectManager.register('attention:window', async ({ element })=>{
      if(!element) return;
      element.classList.add('attention');
      await _awaitTransition(element, 1200*2);
      element.classList.remove('attention');
    });

    effectManager.register('compositor:glass-toggle', async ({ elementList=[], glass })=>{
      for (const el of elementList) {
        if(!el) continue;
        el.style.willChange = 'backdrop-filter, background';
      }
      await _nextFrame();
      for (const el of elementList) el.style.willChange = '';
    });

    effectManager.register('ambient:parallax', ({ root })=>{
      if(!root) return;
      root.classList.add('parallax');
      const onMove = (e)=>{
        const x = (e.clientX / window.innerWidth)  * 10; // 0‚Äì10%
        const y = (e.clientY / window.innerHeight) * 10; // 0‚Äì10%
        root.style.backgroundPosition = `calc(50% + ${x}px) calc(50% + ${y}px), center, center`;
      };
      root.__parallaxMove = onMove;
      window.addEventListener('mousemove', onMove);
    });

    effectManager.register('ambient:parallax:off', ({ root })=>{
      if(!root) return;
      window.removeEventListener('mousemove', root.__parallaxMove);
      root.classList.remove('parallax');
      root.style.backgroundPosition = 'center, center, center';
    });
  }

  /**
   * Compositor: orquesta efectos en respuesta a eventos del WindowManager a trav√©s del EventBus.
   * Mantiene flags expuestos al template (glass/wallpaper/fit) v√≠a proxy a StateManager.
   */
  class Compositor {
    constructor({ bus, stateManager, effectManager }){
      this._bus = bus;
      this._state = stateManager;
      this._effects = effectManager;

      // Exponer como propiedades "reactivas" que ya usa el template
      this.glass = this._state.get('glass');
      this.wallpaper = this._state.get('wallpaper');
      this.fit = this._state.get('fit');

      registerDefaultEffects(this._effects);
      this._bind();
    }

    /**
     * Binds a series of event listeners to the `_bus` event bus for handling
     * various window lifecycle events such as open, close, minimize, focus, blur,
     * and others. Each event handler performs relevant actions such as applying
     * visual effects, calling completion callbacks, or toggling compositor states.
     *
     * @return {void} This method does not return a value.
     */
    _bind(){
      this._bus.on('window.opened', async ({ id })=>{
        const el = this._getEl(id);
        if(!el) return;
        await this._effects.play('transition:open', { id, element: el });
        await this._effects.play('material:shadow:strong', { id, element: el });
      });

      this._bus.on('window.closing', async ({ id, onDone })=>{
        const el = this._getEl(id);
        if(el) await this._effects.play('transition:close', { id, element: el });
        onDone?.();
      });

      this._bus.on('window.minimizing', async ({ id, onDone })=>{
        const el = this._getEl(id);
        if(el) await this._effects.play('transition:minimize', { id, element: el });
        onDone?.();
      });

      this._bus.on('window.focus', async ({ id })=>{
        const el = this._getEl(id); if(!el) return;
        await this._effects.play('material:shadow:strong', { id, element: el });
      });
      this._bus.on('window.blur', async ({ id })=>{
        const el = this._getEl(id); if(!el) return;
        await this._effects.play('material:shadow:weak', { id, element: el });
      });

      this._bus.on('window.restored', async ({ id })=>{
        const el = this._getEl(id); if(!el) return;
        el.classList.remove('is-closing');
        el.classList.add('is-open');
        await this._effects.play('material:shadow:strong', { id, element: el });
      });

      this._bus.on('compositor.toggleGlass', ()=>{
        const snap = this._state.toggle('glass');
        this.glass = snap.glass;
      });
    }

    /**
     * Retrieves an element from the DOM based on a specified window ID.
     *
     * @param {string} id - The unique identifier associated with the desired DOM element.
     * @return {Element*/
    _getEl(id){ return document.querySelector(`.window[data-win-id="${id}"]`); }

    /**
     * Toggles the glass effect by emitting an event through the compositor.
     * This method signals the compositor to enable or disable the glass effect.
     *
     * @return {void} Does not return a value.
     */
    toggleGlass(){ this._bus.emit('compositor.toggleGlass'); }
    setWallpaper(url){ const s=this._state.set('wallpaper', url); this.wallpaper = s.wallpaper; }
    setFit(mode){ const s=this._state.set('fit', mode); this.fit = s.fit; }
  }

  /* Content components (simple, static for MVP) */
  /**
   * About component configuration object.
   *
   * This object defines the properties and template for the About component.
   * It includes a set of properties to be passed, such as translations, and renders
   * an informational grid-style section with key details including role, location,
   * languages, value proposition, and current technical focus areas.
   *
   * Properties:
   * - `props`: An array of properties that the component expects. In this case, it expects `t`, a translation function.
   *
   * Template Output:
   * - A grid structure displaying an about section for a Tech Lead / Architect role.
   * - Contains details such as the role, location, languages, value proposition, and current training or projects.
   * - Includes styling classes such as "grid", "muted", and "hr" for layout and presentation purposes.
   */
  const About = {
    props:['t'],
    template:`<div class="grid">
        <h2>{{ t('about.title') }}</h2>
        <p class="muted">{{ t('about.summary') }}</p>
        <div class="hr"></div>
        <p><strong>Rol:</strong> Tech Lead / Arquitecto ¬∑ <strong>Ubicaci√≥n:</strong> CDMX (Remoto/H√≠brido)</p>
        <p><strong>Idiomas:</strong> Espa√±ol / Ingl√©s (B1+ lectura avanzada)</p>
        <p>Propuesta de valor: orden en entornos ca√≥ticos, decisiones t√©cnicas sostenibles, pedagog√≠a aplicada.</p>
        <p>Actual: re-entrenamiento profundo en PHP 8.3, Python 3.12, Java 21; infraestructura Linux pedag√≥gica; migraciones Docker ‚Üí Kubernetes ‚Üí OpenShift.</p>
      </div>`
  };

  /**
   * A Vue.js component representing professional experience details.
   *
   * The `Experience` component is a reusable Vue.js component designed to display professional
   * experience details with titles, company names, roles, durations, and key achievements.
   *
   * Properties:
   * - `t {Function}`: A function used for localization or translation of content within the component, such as section titles.
   *
   * Template:
   * - Displays a localized title using the `t` function.
   * - Lists professional experiences, including:
   *   * Role titles, company names, and employment periods.
   *   * Relevant achievements and work performed for each position.
   *
   * Usage Context:
   * - Designed to be included in applications requiring a structured display of extensive experience details, e.g., resumes, CV templates, or professional portfolios.
   */
  const Experience = {
    props:['t'],
    template:`<div>
        <h2>{{ t('experience.title') }}</h2>
        <div class="list">
          <p><strong>Technical Lead ‚Äî Nyx (2023‚ÄìPresente):</strong> Arquitectura AWS, automatizaci√≥n, est√°ndares de calidad y observabilidad.</p>
          <p><strong>Senior Software Engineer ‚Äî Vass Latam / Telef√≥nica Chile (2021‚Äì2023):</strong> Magento 2.4; refactor de pagos; -70% errores cr√≠ticos; checkout m√°s r√°pido.</p>
          <p><strong>Senior Backend ‚Äî PagoF√°cil.net (2018‚Äì2021):</strong> Gateway CNP para Magento 2.3; facturaci√≥n electr√≥nica; antifraude.</p>
          <p><strong>Developer / Jr PM ‚Äî Enova (2014‚Äì2018):</strong> Scrum + XP, documentaci√≥n t√©cnica, entregables en proyectos educativos.</p>
          <p><strong>Freelance / Consultor (2008‚Äì2014):</strong> PHP full‚Äëstack, Linux admin, soporte Java; e‚Äëcommerce e institucional.</p>
        </div>
      </div>`
  };

  /**
   * Vue.js component that represents a section showcasing various skills and expertise.
   *
   * This component is used to display categorized professional skills and tools,
   * including programming languages, frameworks, databases, cloud infrastructure,
   * software architectures, and system-related expertise.
   *
   * Properties:
   * - `props`: An array containing a single prop `t`, which is a function used for translations.
   *
   * Structure:
   * - The component consists of a title and a grid layout with two columns.
   * - The left column lists programming languages, frameworks, and database technologies.
   * - The right column lists cloud infrastructure, architectural patterns, and system tools.
   *
   * Features:
   * - Dynamically renders a translated title using the `t` function provided via props.
   * - Organized information with semantic tags for better readability.
   * - Highlights key skills and technologies with bold text to improve visibility.
   */
  const Skills = {
    props:['t'],
    template:`<div>
        <h2>{{ t('skills.title') }}</h2>
        <div class="grid cols-2">
          <div>
            <p><strong>Lenguajes:</strong> PHP 8 ¬∑ Python 3 ¬∑ Java 21 ¬∑ C# ¬∑ JS/TS</p>
            <p><strong>Frameworks:</strong> Laravel ¬∑ Symfony ¬∑ Magento 2 ¬∑ FastAPI ¬∑ Spring Boot ¬∑ .NET</p>
            <p><strong>Bases:</strong> DocumentDB/Mongo ¬∑ MySQL ¬∑ PostgreSQL ¬∑ Oracle</p>
          </div>
          <div>
            <p><strong>Cloud & Infra:</strong> AWS (Lambda, CloudFront, IAM, S3, DocumentDB, CloudWatch) ¬∑ Docker ¬∑ K8s ¬∑ OpenShift</p>
            <p><strong>Arquitectura:</strong> Clean Architecture ¬∑ DDD ¬∑ SOLID ¬∑ CQRS ¬∑ CI/CD</p>
            <p><strong>Sistemas:</strong> Linux ¬∑ Bash ¬∑ Git (plumbing/porcelain)</p>
          </div>
        </div>
      </div>`
  };

  /**
   * Represents an education component that displays details about formal education,
   * additional training, and ongoing courses.
   *
   * @property {Array} props - An array containing properties passed to the component. Here, it includes `t`, a translation function.
   * @property {String} template - A string defining the HTML structure of the education component. It includes information about
   * educational qualifications, complementary courses, and current learning endeavors.
   */
  const Education = {
    props:['t'],
    template:`<div>
        <h2>{{ t('education.title') }}</h2>
        <p><strong>Ing. en Sistemas Computacionales</strong> ‚Äî M√©xico</p>
        <p>Complementos: PMBOK 7, Lean Delivery, DevOps, Conflict Management, Leadership for Tech Teams.</p>
        <p>En curso: Kubernetes ‚Üí OpenShift y actualizaci√≥n avanzada de PHP / Python / Java.</p>
      </div>`
  };

  /**
   * Download is a Vue component that provides downloadable and viewable resources, such as a CV, along with links to external social media or personal pages.
   *
   * @property {Array<string>} props - Accepts a single prop `t` which is a function used for localization of UI text.
   *
   * @emits {string} open-viewer - Triggered when the "Ver CV" link is clicked. Emits an object with `src`, `type`, and `title` properties.
   * @emits {string} download - Triggered when the "CV ‚Äî PDF" link is clicked to download the file.
   *
   * @template A Vue template structure that includes:
   * - A title and hint section, both localized using the `t` prop.
   * - Links for downloading or viewing a CV.
   * - A section with links to external platforms such as LinkedIn, GitHub, and a blog.
   */
  const Download = {
    props:['t'],
    emits:['open-viewer','download'],
    template:`<div>
        <h2>{{ t('download.title') }}</h2>
        <p class="muted">{{ t('download.hint') }}</p>
        <p><a class="link" href="/cv/angel-barrientos.pdf" download @click="$emit('download')">‚¨á CV ‚Äî PDF</a></p>
        <p><a class="link" href="#" @click.prevent="$emit('open-viewer',{src:'/cv/angel-barrientos.pdf',type:'pdf',title:'CV de √Ångel'})">üóé Ver CV</a></p>
        <div class="hr"></div>
        <p><a class="link" href="https://linkedin.com/in/uetiko" target="_blank" rel="noopener">LinkedIn</a> ¬∑ <a class="link" href="https://github.com/uetiko" target="_blank" rel="noopener">GitHub</a> ¬∑ <a class="link" href="https://blog.uetiko.com" target="_blank" rel="noopener">Blog</a></p>
      </div>`
  };

  /**
   * A Vue.js component representing a contact form.
   *
   * The `Contact` component provides a simple contact form with fields for name, email, and message.
   * It includes a title fetched dynamically using a translation function, a styled email link,
   * and a submission handler for emitting form data upon user submission.
   *
   * Properties:
   * - `props`: An array containing property names used by the component. Currently includes:
   *   - `t`: A function used for dynamic text translation.
   *
   * Template:
   * - The template includes:
   *   - A title, which is dynamically rendered using the `t` function.
   *   - An email contact link.
   *   - A form with:
   *     - Two input fields (`name` and `email`) styled for user input.
   *     - A textarea for entering a message.
   *     - A submit button triggering a `submit` event with form status and ID upon submission.
   *
   * Events:
   * - `submit`: Emitted when the form is submitted. The payload contains:
   *   - `form_id`: The identifier of the form.
   *   - `status`: The submission status, defaulting to 'ok'.
   */
  const Contact = {
    props:['t'],
    template:`<div>
        <h2>{{ t('contact.title') }}</h2>
        <p>üìß <a class="link" href="mailto:angel@uetiko.com">angel@uetiko.com</a></p>
        <form @submit.prevent="$emit('submit',{form_id:'contact', status:'ok'})">
          <div class="grid cols-2">
            <input required name="name" placeholder="Nombre" style="padding:10px;border-radius:8px;border:1px solid #1c2736;background:#0b1118;color:var(--text)" />
            <input required name="email" placeholder="Email" type="email" style="padding:10px;border-radius:8px;border:1px solid #1c2736;background:#0b1118;color:var(--text)" />
          </div>
          <textarea required name="msg" placeholder="Mensaje" rows="5" style="margin-top:10px;padding:10px;border-radius:8px;border:1px solid #1c2736;background:#0b1118;color:var(--text); width:100%"></textarea>
          <div style="margin-top:10px"><button class="btn" type="submit">Enviar</button></div>
        </form>
      </div>`
  };

  /**
   * DocumentViewer is a component that displays a document passed via the `src` property.
   * It supports different file types such as images or PDFs and adapts its rendering logic based on the type.
   * Additionally, it provides telemetry functionalities for tracking user interactions like downloads and window state changes.
   *
   * Props:
   * @prop {string} src - The source URL of the document to be displayed. This should be a valid URL pointing to a file.
   * @prop {string} type - The type of the document to be displayed. It accepts 'image', 'pdf', or other supported types.
   * @prop {string} title - The title of the document, displayed at the top of the viewer.
   * @prop {Object} telemetry - An object for managing telemetry events. It must have methods `download`, `openWindow`, and `closeWindow`.
   *
   * Behavior:
   * - Renders the document inside the component area based on its type. For example:
   *   - Renders an `<img>` tag for image files.
   *   - Renders an `<iframe>` tag for PDFs or other types.
   * - Displays a download link that allows users to download the document. A `telemetry.download` event is triggered on download.
   * - Tracks when the viewer is mounted and unmounted using `telemetry.openWindow` and `telemetry.closeWindow` respectively.
   *
   * Styling:
   * - Uses a flexbox layout for managing the title bar and download link.
   * - Ensures responsive behavior by creating a grid layout with an auto header and an expandable document viewing area.
   */
  const DocumentViewer = {
    props: ['src', 'type', 'title', 'telemetry'],
    template: `
      <div style="display:grid;grid-template-rows:auto 1fr;height:100%;">
        <div style="display:flex;justify-content:space-between;align-items:center;padding:8px 0;">
          <strong>{{ title }}</strong>
          <div>
            <a class="link" :href="src" download @click="telemetry.download({file_name: src.split('/').pop(), element:'download_link'})">‚¨á Descargar</a>
          </div>
        </div>
        <div style="width:100%;height:100%;border-radius:8px;overflow:hidden;background:#0b1118;">
          <component :is="componentType" :src="src" style="width:100%;height:100%;border:none;object-fit:contain;" />
        </div>
      </div>
    `,
    computed: {
      componentType() {
        switch (this.type) {
          case 'image': return 'img';
          case 'pdf': return 'iframe';
          default: return 'iframe';
        }
      }
    },
    mounted() {
      this.telemetry.openWindow('document_viewer', {file: this.src, type: this.type});
    },
    unmounted() {
      this.telemetry.closeWindow('document_viewer', {file: this.src});
    }
  };

  const { createApp, onMounted, ref, reactive, computed } = Vue;

  /**
   * Represents the main application instance created via `createApp` function with setup logic.
   *
   * This variable encompasses a Vue application instance configured with its components, reactive state management,
   * event handling, window management, and telemetry integration.
   *
   * Components included:
   * - About
   * - Experience
   * - Skills
   * - Education
   * - Download
   * - Contact
   * - DocumentViewer
   *
   * The setup function initializes and configures several key functionalities such as:
   * - Language detection and i18n handling.
   * - Telemetry for tracking user interactions and page views.
   * - Window management system for creating, focusing, minimizing, restoring, resizing, and closing windows.
   * - Event bus for inter-component communication.
   * - Media query handling for preferences like reduced motion.
   * - Reactive state objects for maintaining UI state, windows, tasks, and effects.
   * - Drag-and-drop and resizing interactions for UI elements.
   *
   * The setup also includes various utility methods like `makeWin`, `focus`, `openApp`, and event-specific handlers
   * (e.g., `startDrag`, `onDrag`, `endDrag`) to enhance and manage app interactions dynamically.
   */
  const app = createApp({
    components: { About, Experience, Skills, Education, Download, Contact, DocumentViewer },
    setup() {
      const env = (new URLSearchParams(location.search).get('env')) || 'dev';
      const appName = 'retro-desktop';
      const lang = ref((navigator.language || 'es').startsWith('es') ? 'es' : 'en');
      const t = (key) => i18n(lang.value)(key);

      const telemetry = new Telemetry({ env, app: appName });
      telemetry.pageView();

      const wm = new WindowManager();
      const bus = new EventBus();
      const mq = matchMedia('(prefers-reduced-motion: reduce)');
      const stateManager = new StateManager({
        glass: true,
        animationSpeed: 1.0,
        reducedMotion: mq.matches
      });
      const effectManager = new EffectManager({ bus, state: stateManager, telemetry });
      const compositor = reactive(new Compositor({ bus, stateManager, effectManager }));

      const windows = reactive([]);
      const tasks = reactive([]);

      /**
       * Creates and manages the lifecycle of a new window instance.
       *
       * This function is responsible for creating new windows, restoring
       * existing ones if they are already opened, and managing associated
       * tasks and event emissions.
       *
       * @param {string} id - A unique identifier for the window instance.
       * @param {string} title - The title to display in the window.
       * @param {string} icon - The path or key for the icon to display with the window.
       * @param {Function} component - The component or function to render within the window.
       * @param {Object} [props={}] - Optional props passed to the component for customization.
       */
      const makeWin = (id, title, icon, component, props = {}) => {
        if (wm.find(id)) { wm.restore(id); focus(id); return; }
        const w = wm.create({ id, title, icon, component });
        windows.push({ id, title, icon, component, props, get style(){ return wm.style(w); } });
        tasks.push({ id, title, active: true });
        focus(id);
        requestAnimationFrame(()=> bus.emit('window.opened', { id }));
      };

      /**
       * Opens a new document viewer window for displaying a file.
       *
       * @function
       * @param {Object} payload - The payload containing file details for the viewer.
       * @param {string} payload.src - The source path or URL of the document to be viewed.
       * @param {string} payload.type - The type or format of the document (e.g., PDF, image).
       * @param {string} payload.title - The title to be displayed on the viewer window.
       */
      const openViewer = (payload) => {
        const { src, type, title } = payload;
        const id = `viewer-${uuidv4()}`;
        makeWin(id, title, 'üóé', 'DocumentViewer', { src, type, title, telemetry });
        telemetry.openWindow('document_viewer', {file: src, type});
      };

      /**
       * Changes the focus to a specific task by its ID.
       *
       * When a task gains focus, the previously focused task is blurred if present,
       * and the focus event is emitted. It updates the task's `active` state and notifies
       * with appropriate events.
       *
       * @param {string} id - The identifier of the task to focus.
       */
      const focus = (id) => {
        const prev = tasks.find(t=>t.active);
        if(prev && prev.id !== id) bus.emit('window.blur', { id: prev.id });
        wm.focus(id);
        tasks.forEach(t=>t.active = (t.id===id));
        bus.emit('window.focus', { id });
      };
      /**
       * Minimizes a window identified by the given ID.
       *
       * The function emits a 'window.minimizing' event via the bus with the window ID
       * and an "onDone" callback. Once the "onDone" callback is triggered, the window
       * is minimized using the window manager and its corresponding task is marked
       * as inactive if found in the task list.
       *
       * @param {string} id - The unique identifier of the window to be minimized.
       */
      const minimize = (id) => {
        bus.emit('window.minimizing', {
          id,
          onDone: () => {
            wm.minimize(id);
            const t = tasks.find(t=>t.id===id); if(t) t.active = false;
          }
        });
      };
      /**
       * Restores a window or task identified by the given ID.
       *
       * This function performs the following actions:
       * 1. Calls the `restore` method from the `wm` module to restore the window.
       * 2. Finds the task associated with the provided ID and marks it as active.
       * 3. Emits the `window.restored` event with the associated ID.
       * 4. Emits the `window.focus` event with the associated ID.
       *
       * @param {string|number} id - The unique identifier of the window or task to restore.
       */
      const restore = (id) => {
        wm.restore(id);
        const t = tasks.find(t=>t.id===id); if(t) t.active = true;
        bus.emit('window.restored', { id });   // üëà nuevo
        bus.emit('window.focus', { id });
      };
      const toggleMaximize = (id) => {
        wm.toggleMax(id);
        wm.syncToDOM(id);
        bus.emit('window.maximized', { id });
      };
      /**
       * Closes a window and performs associated cleanup operations.
       *
       * Emits a 'window.closing' event with the specified window ID and provides a callback
       * to clean up resources and update the state by removing the window and its
       * corresponding task entry from their respective lists.
       *
       * @param {string} id - The identifier of the window to be closed.
       */
      const closeWindow = (id) => {
        bus.emit('window.closing', {
          id,
          onDone: () => {
            wm.close(id);
            const idx = windows.findIndex(w=>w.id===id); if(idx>-1) windows.splice(idx,1);
            const tidx = tasks.findIndex(t=>t.id===id); if(tidx>-1) tasks.splice(tidx,1);
          }
        });
      };

      /**
       * Opens a specified application window based on the provided name.
       *
       * Depending on the name parameter, the function triggers the creation of a new application
       * window with predefined attributes such as ID, title, icon, and additional content descriptor.
       * It also logs a telemetry event for tracking purposes.
       *
       * @param {string} name - The name of the application to open. Accepted values are:
       *                        'about', 'experience', 'skills', 'education', 'download', 'contact'.
       *                        Each corresponds to a specific application window.
       * @throws {Error} If no matching case is found for the provided name.
       */
      const openApp = (name) => {
        switch(name){
          case 'about': makeWin('about', t('menu.about'), 'üõà', 'About'); break;
          case 'experience': makeWin('experience', t('menu.experience'), 'üíº', 'Experience'); break;
          case 'skills': makeWin('skills', t('menu.skills'), 'üß∞', 'Skills'); break;
          case 'education': makeWin('education', t('menu.education'), 'üéì', 'Education'); break;
          case 'download': makeWin('download', t('menu.download'), '‚¨á', 'Download'); break;
          case 'contact': makeWin('contact', t('menu.contact'), '‚úâ', 'Contact'); break;
        }
        telemetry.cta('open_app', { name });
      };

      // Drag/Resize
      /**
       * An object representing the state and attributes of a drag operation.
       *
       * @property {boolean} active - Indicates if a drag operation is currently active.
       * @property {null|string|number} id - The identifier of the draggable element, initially set to null.
       * @property {number} startX - The x-coordinate where the drag operation started.
       * @property {number} startY - The y-coordinate where the drag operation started.
       * @property {Object} start - Stores the initial state or references at the start of the drag operation.
       * @property {boolean} ghost - Determines if a ghost element is being used during the drag operation.
       * @property {string} ghostStyle - Specifies the CSS style applied to the ghost element.
       */
      const drag = reactive({ active:false, id:null, startX:0, startY:0, start:{}, ghost:false, ghostStyle:'' });
      /**
       * Handles the initiation of a drag action for a draggable element.
       *
       * @param {MouseEvent} e - The mouse event that triggered the drag start.
       * @param {string | number} id - The unique identifier of the element being dragged.
       *
       * Initializes the drag state including the starting position of the mouse, the starting position of the element,
       * and applies a "ghost" representation of the drag. Attaches mousemove and mouseup event listeners to handle the
       * drag action and its termination respectively.
       */
      const startDrag = (e, id) => {
        const w = wm.find(id); if(!w) return;
        if (w.maximized) {
          bus.emit('window.feedback', { id, kind: 'shake' });
          return;
        }
        drag.active = true; drag.id = id; drag.startX = e.clientX; drag.startY = e.clientY; drag.start = { x:w.x, y:w.y };
        drag.ghost = true; drag.ghostStyle = `left:${w.x}px;top:${w.y}px;width:${w.w}px;height:${w.h}px;`;
        window.addEventListener('mousemove', onDrag); window.addEventListener('mouseup', endDrag);
      };
      /**
       * Handles the drag event for an interactive element.
       *
       * This function is triggered when a drag action is in progress, updating the
       * position of the dragged element based on the cursor's movement. If the drag
       * is not active or the target element cannot be found, the function exits
       * early. While the drag is in motion, the ghost representation of the element
       * is updated to follow the cursor's position, using calculated coordinates
       * relative to its starting position.
       *
       * @param {Event} e - The event object associated with the drag action, containing details
       * about the cursor's position and other event properties.
       */
      const onDrag = (e) => {
        if(!drag.active) return; const w = wm.find(drag.id); if(!w) return;
        const nx = drag.start.x + (e.clientX - drag.startX); const ny = drag.start.y + (e.clientY - drag.startY);
        drag.ghostStyle = `left:${nx}px;top:${ny}px;width:${w.w}px;height:${w.h}px;`;
      };
      /**
       * Handles the end of a drag operation, finalizing the position of the dragged element
       * and cleaning up event listeners and drag-related state.
       *
       * @param {MouseEvent} e - The mouse event triggered when the drag ends.
       * @returns {void}
       */
      const endDrag = (e) => {
        if(!drag.active) return; const w = wm.find(drag.id); if(!w) return;
        const nx = drag.start.x + (e.clientX - drag.startX); const ny = drag.start.y + (e.clientY - drag.startY);
        w.x = Math.max(4, Math.min(nx, innerWidth - 60)); w.y = Math.max(4, Math.min(ny, innerHeight - 100));
        drag.active=false; drag.id=null; drag.ghost=false; drag.ghostStyle='';
        window.removeEventListener('mousemove', onDrag); window.removeEventListener('mouseup', endDrag);
      };

      /**
       * Initiates a drag-and-resize interaction for a user interface element.
       *
       * This function sets up the necessary state and event listeners to allow resizing of a UI element. It tracks
       * the initial dimensions and position of the element, as well as the starting mouse position. The function
       * calculates the new dimensions dynamically as the mouse moves while enforcing minimum size constraints.
       * Resize updates are visualized using a ghost element until the resizing operation is completed.
       *
       * @param {MouseEvent} e - The mouse event object that contains the starting position of the mouse and
       * contextual information for the "mousedown" or similar triggering event.
       * @param {string} id - The unique identifier of the element to be resized, used to look up and update
       * its properties in the window manager (wm).
       */
      const startResize = (e, id) => {
        e.stopPropagation(); const w = wm.find(id); if(!w) return;
        drag.active = true; drag.id = id; drag.startX = e.clientX; drag.startY = e.clientY; drag.start = { w:w.w, h:w.h };
        drag.ghost = true; drag.ghostStyle = `left:${w.x}px;top:${w.y}px;width:${w.w}px;height:${w.h}px;`;
        const onMove = (ev) => {
          const nw = Math.max(340, drag.start.w + (ev.clientX - drag.startX));
          const nh = Math.max(220, drag.start.h + (ev.clientY - drag.startY));
          drag.ghostStyle = `left:${w.x}px;top:${w.y}px;width:${nw}px;height:${nh}px;`;
        };
        /**
         * Handles the "mouseup" event for a drag-and-resize operation on a user interface element.
         *
         * This function calculates the new width and height of the draggable or resizable UI element based on
         * the mouse's current position relative to the starting drag position. It ensures that the dimensions
         * do not fall below a minimum size and do not exceed the screen boundaries. After handling the resize,
         * it cleans up the drag state and removes related event listeners.
         *
         * @param {MouseEvent} ev - The mouse event object that contains the current position of the mouse
         * and contextual information for the "mouseup" event.
         */
        const onUp = (ev) => {
          const nw = Math.max(340, drag.start.w + (ev.clientX - drag.startX));
          const nh = Math.max(220, drag.start.h + (ev.clientY - drag.startY));
          w.w = Math.min(nw, innerWidth - w.x - 12); w.h = Math.min(nh, innerHeight - w.y - 54);
          drag.active=false; drag.id=null; drag.ghost=false; drag.ghostStyle='';
          window.removeEventListener('mousemove', onMove); window.removeEventListener('mouseup', onUp);
        };
        window.addEventListener('mousemove', onMove); window.addEventListener('mouseup', onUp);
      };

      /**
       * A reactive variable that holds a string value representing the clock.
       * This can be used to store and update a time-related string dynamically.
       *
       * The variable is initialized with an empty string.
       * Updates to this variable will automatically trigger reactivity in frameworks
       * that support reactive data bindings (e.g., Vue with ref()).
       */
      const clock = ref('');
      const tick = () => {
        const date = new Date();
        //clock.value = date.toISOString().substring(11,19) + 'Z';
        clock.value = date.toLocaleString('en-US', {
          hour: 'numeric',
          minute: 'numeric',
          hour12: true,
          timeZoneName: 'short'
        });
      };
      setInterval(tick, 1000); tick();

      const ui = reactive({ menu:false });

      const setLang = (l) => { lang.value = l; telemetry.cta('lang_switch', { variant:l }); };

      onMounted(() => {
        // Open About by default
        openApp('about');
      });

      return {
        env, appName, lang, t, telemetry,
        compositor, windows, tasks, ui,
        openApp, openViewer, focus, minimize, restore, toggleMaximize, closeWindow,
        startDrag, startResize, drag,
        clock, setLang
      };
    }
  });

  // Outside click directive for menu
  app.directive('click', { beforeMount(el, binding){ el.__clickOutside__ = (e)=>{ if(!(el===e.target||el.contains(e.target))) binding.value(e); }; document.addEventListener('click', el.__clickOutside__); }, unmounted(el){ document.removeEventListener('click', el.__clickOutside__); } });

  app.mount('#app');
</script>
</body>
</html>
